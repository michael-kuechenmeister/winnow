
package structs;

import "winnow/console";
import "bytes";
import "strconv";
import "strings";
import "time";



func isAlphabet (chunk string) bool {

	var result bool = true;

	for c := 0; c < len(chunk); c++ {

		var character = string(chunk[c]);

		if character >= "0" && character <= "9" {
			continue;
		} else if character >= "A" && character <= "Z" {
			continue;
		} else if character >= "a" && character <= "z" {
			continue;
		} else {
			result = false;
			break;
		}

	}

	return result;

}

func isNumber (chunk string) bool {

	var result bool = true;

	for c := 0; c < len(chunk); c++ {

		var character = string(chunk[c]);

		if character >= "0" && character <= "9" {
			continue;
		} else {
			result = false;
			break;
		}

	}

	return result;

}



type Vulnerability struct {

	Identifier  string     `json:"identifier"`;
	Description string     `json:"description"`;
	Type        string     `json:"type"`;
	Severity    string     `json:"severity"`;
	State       string     `json:"state"`;
	Datetime    string     `json:"datetime"`;
	IsEdited    bool       `json:"is_edited"`;

	Hardware    []Hardware `json:"hardware"`;
	Software    []Software `json:"software"`;
	Products    []Product  `json:"products"`;
	References  []string   `json:"references"`;
	Weaknesses  []string   `json:"weaknesses"`;

}



func IsVulnerability (vulnerability Vulnerability) bool {

	var result bool = true;

	// TODO: Validate Vulnerability

	return result;

}

func NewVulnerability () Vulnerability {

	var vulnerability Vulnerability;

	vulnerability.Type       = "none";
	vulnerability.Severity   = "none";
	vulnerability.State      = "invalid";
	vulnerability.Datetime   = time.Now().Format("2006-01-02T15:04:05Z");
	vulnerability.Hardware   = make([]Hardware, 0);
	vulnerability.Software   = make([]Software, 0);
	vulnerability.Products   = make([]Product, 0);
	vulnerability.References = make([]string, 0);
	vulnerability.Weaknesses = make([]string, 0);

	return vulnerability;

}

func (vulnerability *Vulnerability) ToLog () string {

	var buffer bytes.Buffer;

	buffer.WriteString("Vulnerability({\n");
	buffer.WriteString("    Identifier: \""  + vulnerability.Identifier                   + "\",\n");
	buffer.WriteString("    Description: \"" + vulnerability.Description                  + "\",\n");
	buffer.WriteString("    Type: \""        + vulnerability.Type                         + "\",\n");
	buffer.WriteString("    Severity: \""    + vulnerability.Severity                     + "\",\n");
	buffer.WriteString("    State: \""       + vulnerability.State                        + "\",\n");
	buffer.WriteString("    IsEdited: "      + strconv.FormatBool(vulnerability.IsEdited) + ",\n");
	buffer.WriteString("    Hardware: [\n");

	if len(vulnerability.Hardware) > 0 {

		for h := 0; h < len(vulnerability.Hardware); h++ {

			var chunk = vulnerability.Hardware[h].ToLog();

			if h < len(vulnerability.Hardware) - 1 {
				chunk += ",";
			}

			var chunks = strings.Split(chunk, "\n");

			for c := 0; c < len(chunks); c++ {
				buffer.WriteString("        " + chunks[c] + "\n");
			}

		}

	}

	buffer.WriteString("    ],\n");
	buffer.WriteString("    References: [\n");

	if len(vulnerability.References) > 0 {

		for r := 0; r < len(vulnerability.References); r++ {

			var chunk = "\"" + vulnerability.References[r] + "\"";

			if r < len(vulnerability.References) - 1 {
				chunk += ",";
			}

			buffer.WriteString("        " + chunk + "\n");

		}

	}

	buffer.WriteString("    ],\n");
	buffer.WriteString("    Software: [\n");

	if len(vulnerability.Software) > 0 {

		for s := 0; s < len(vulnerability.Software); s++ {

			var chunk = vulnerability.Software[s].ToLog();

			if s < len(vulnerability.Software) - 1 {
				chunk += ",";
			}

			var chunks = strings.Split(chunk, "\n");

			for c := 0; c < len(chunks); c++ {
				buffer.WriteString("        " + chunks[c] + "\n");
			}

		}

	}

	buffer.WriteString("    ],\n");
	buffer.WriteString("    Weaknesses: [\n");

	if len(vulnerability.Weaknesses) > 0 {

		for w := 0; w < len(vulnerability.Weaknesses); w++ {

			var chunk = "\"" + vulnerability.Weaknesses[w] + "\"";

			if w < len(vulnerability.Weaknesses) - 1 {
				chunk += ",";
			}

			buffer.WriteString("        " + chunk + "\n");

		}

	}

	buffer.WriteString("    ],\n");
	buffer.WriteString("})");

	return buffer.String();

}

func (vulnerability *Vulnerability) Log () {

	var buffer = vulnerability.ToLog();
	var chunks = strings.Split(buffer, "\n");

	for c := 0; c < len(chunks); c++ {
		console.Log(chunks[c]);
	}

}

func (vulnerability *Vulnerability) SetIdentifier (value string) {

	if strings.Contains(value, "-") {

		if strings.HasPrefix(value, "CVE-") {
			// CVE

			var tmp = strings.Split(value, "-");

			if len(tmp) == 3 && isNumber(tmp[1]) && isNumber(tmp[2]) {
				vulnerability.Identifier = value;
			}

		} else if strings.HasPrefix(value, "ALSA-") {
			// Alma Linux

			var tmp = strings.Split(value, "-");

			if len(tmp) == 3 && isNumber(tmp[1]) && isNumber(tmp[2]) {
				vulnerability.Identifier = value;
			}

		} else if strings.HasPrefix(value, "DLA-") || strings.HasPrefix(value, "DSA-") || strings.HasPrefix(value, "DTSA-") {
			// Debian

			var tmp = strings.Split(value, "-");

			if len(tmp) == 2 && isNumber(tmp[1]) {
				vulnerability.Identifier = value;
			} else if len(tmp) == 3 && isNumber(tmp[1]) && isNumber(tmp[2]) {
				vulnerability.Identifier = value;
			}

		} else if strings.HasPrefix(value, "ELSA-") {
			// Oracle Linux

			var tmp = strings.Split(value, "-");

			if len(tmp) == 3 && isNumber(tmp[1]) && isNumber(tmp[2]) {
				vulnerability.Identifier = value;
			}

		} else if strings.HasPrefix(value, "GHSA-") {
			// GitHub

			var tmp = strings.Split(value, "-");

			if len(tmp) == 4 && len(tmp[1]) == 4 && isAlphabet(tmp[1]) && len(tmp[2]) == 4 && isAlphabet(tmp[2]) && len(tmp[3]) == 4 && isAlphabet(tmp[3]) {
				vulnerability.Identifier = value;
			}

		} else if strings.HasPrefix(value, "LSN-") || strings.HasPrefix(value, "USN-") {
			// Ubuntu

			var tmp = strings.Split(value, "-");

			if len(tmp) == 3 && isNumber(tmp[1]) && isNumber(tmp[2]) {
				vulnerability.Identifier = value;
			}

		} else if strings.HasPrefix(value, "RLBA-") || strings.HasPrefix(value, "RLEA-") || strings.HasPrefix(value, "RLSA-") {
			// Rocky Linux

			var tmp = strings.Split(value, "-");

			if len(tmp) == 3 && isNumber(tmp[1]) && isNumber(tmp[2]) {
				vulnerability.Identifier = value;
			}

		}

	}

}

func (vulnerability *Vulnerability) SetDescription (value string) {

	var filtered string;

	for _, chunk := range value {

		if chunk == 9 {
			filtered = filtered + "    ";
		} else if chunk < 128 {
			filtered = filtered + string(chunk);
		} else if chunk == 160 {
			filtered = filtered + " ";
		} else if chunk == 8211 {
			filtered = filtered + "-";
		} else if chunk == 8239 {
			filtered = filtered + " ";
		}

	}

	if len(filtered) > 0 {
		vulnerability.Description = filtered;
	}

}

func (vulnerability *Vulnerability) AddType (value string) {

	var current = vulnerability.Type;

	if current == "none" {

		vulnerability.SetType(value);

	} else if current == "physical" {

		if value == "local" || value == "adjacent" || value == "network" {
			vulnerability.SetType(value);
		}

	} else if current == "local" {

		if value == "adjacent" || value == "network" {
			vulnerability.SetType(value);
		}

	} else if current == "adjacent" {

		if value == "network" {
			vulnerability.SetType(value);
		}

	} else if current == "network" {
		// Do Nothing
	}

}

func (vulnerability *Vulnerability) SetType (value string) {

	if value == "none" {
		vulnerability.Type = "none";
	} else if value == "physical" {
		vulnerability.Type = "physical";
	} else if value == "local" {
		vulnerability.Type = "local";
	} else if value == "adjacent" {
		vulnerability.Type = "adjacent";
	} else if value == "network" {
		vulnerability.Type = "network";
	}

}

func (vulnerability *Vulnerability) AddSeverity (value string) {

	var current = vulnerability.Severity;

	if current == "none" {

		vulnerability.SetSeverity(value);

	} else if current == "low" {

		if value == "medium" || value == "high" || value == "critical" {
			vulnerability.SetSeverity(value);
		}

	} else if current == "medium" {

		if value == "high" || value == "critical" {
			vulnerability.SetSeverity(value);
		}

	} else if current == "high" {

		if value == "critical" {
			vulnerability.SetSeverity(value);
		}

	} else if current == "critical" {
		// Do Nothing
	}

}

func (vulnerability *Vulnerability) SetSeverity (value string) {

	if value == "none" {
		vulnerability.Severity = "none";
	} else if value == "low" {
		vulnerability.Severity = "low";
	} else if value == "medium" {
		vulnerability.Severity = "medium";
	} else if value == "high" {
		vulnerability.Severity = "high";
	} else if value == "critical" {
		vulnerability.Severity = "critical";
	}

}

func (vulnerability *Vulnerability) SetState (value string) {

	if value == "published" {
		vulnerability.State = "published";
	} else if value == "disputed" {
		vulnerability.State = "disputed";
	} else if value == "rejected" {
		vulnerability.State = "rejected";
	} else if value == "reserved" {
		vulnerability.State = "reserved";
	} else if value == "invalid" {
		vulnerability.State = "invalid";
	}

}

func (vulnerability *Vulnerability) AddDatetime (value string) {

	var datetime1 = NewDatetime(vulnerability.Datetime);
	var datetime2 = NewDatetime(value);

	if datetime2.IsEarlierThan(datetime1) {
		vulnerability.Datetime = datetime2.String();
	}

}

func (vulnerability *Vulnerability) SetDatetime (value string) {

	var datetime = NewDatetime(value);

	if datetime.Year != 0 && datetime.Month != 0 && datetime.Day != 0 {
		vulnerability.Datetime = datetime.String();
	}

}

func (vulnerability *Vulnerability) SetEdited (value bool) {
	vulnerability.IsEdited = value;
}

func (vulnerability *Vulnerability) AddHardware (value Hardware) {

	var found bool = false;

	for h := 0; h < len(vulnerability.Hardware); h++ {

		var other = vulnerability.Hardware[h];

		if IsIdenticalHardware(other, value) {
			found = true;
			break;
		}

	}

	if found == false {
		vulnerability.Hardware = append(vulnerability.Hardware, value);
	}

}

func (vulnerability *Vulnerability) RemoveHardware (value Hardware) {

	var index int = -1;

	for h := 0; h < len(vulnerability.Hardware); h++ {

		var other = vulnerability.Hardware[h];

		if IsIdenticalHardware(other, value) {
			index = h;
			break;
		}

	}

	if index != -1 {
		vulnerability.Hardware = append(vulnerability.Hardware[:index], vulnerability.Hardware[index + 1:]...);
	}

}

func (vulnerability *Vulnerability) SetHardware (value []Hardware) {

	var filtered []Hardware;

	for v := 0; v < len(value); v++ {

		var hardware = value[v];

		if IsHardware(hardware) {
			filtered = append(filtered, hardware);
		}

	}

	vulnerability.Hardware = filtered;

}

func (vulnerability *Vulnerability) AddSoftware (value Software) {

	var found bool = false;

	for s := 0; s < len(vulnerability.Software); s++ {

		var other = vulnerability.Software[s];

		if IsIdenticalSoftware(other, value) {
			found = true;
			break;
		}

	}

	if found == false {
		vulnerability.Software = append(vulnerability.Software, value);
	}

}

func (vulnerability *Vulnerability) RemoveSoftware (value Software) {

	var index int = -1;

	for s := 0; s < len(vulnerability.Software); s++ {

		var other = vulnerability.Software[s];

		if IsIdenticalSoftware(other, value) {
			index = s;
			break;
		}

	}

	if index != -1 {
		vulnerability.Software = append(vulnerability.Software[:index], vulnerability.Software[index + 1:]...);
	}

}

func (vulnerability *Vulnerability) SetSoftware (value []Software) {

	var filtered []Software;

	for v := 0; v < len(value); v++ {

		var software = value[v];

		if IsSoftware(software) {
			filtered = append(filtered, software);
		}

	}

	vulnerability.Software = filtered;

}

func (vulnerability *Vulnerability) AddProduct (value Product) {

	var found bool = false;

	for p := 0; p < len(vulnerability.Products); p++ {

		var other = vulnerability.Products[p];

		if IsIdenticalProduct(other, value) {
			found = true;
			break;
		}

	}

	if found == false {
		vulnerability.Products = append(vulnerability.Products, value);
	}

}

func (vulnerability *Vulnerability) RemoveProduct (value Product) {

	var index int = -1;

	for p := 0; p < len(vulnerability.Products); p++ {

		var other = vulnerability.Products[p];

		if IsIdenticalProduct(other, value) {
			index = p;
			break;
		}

	}

	if index != -1 {
		vulnerability.Products = append(vulnerability.Products[:index], vulnerability.Products[index + 1:]...);
	}

}

func (vulnerability *Vulnerability) SetProducts (value []Product) {

	var filtered []Product;

	for v := 0; v < len(value); v++ {

		var product = value[v];

		if IsProduct(product) {
			filtered = append(filtered, product);
		}

	}

	vulnerability.Products = filtered;

}

func (vulnerability *Vulnerability) AddReference (value string) {

	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {

		var found bool = false;

		for r := 0; r < len(vulnerability.References); r++ {

			var reference = vulnerability.References[r];

			if reference == value {
				found = true;
				break;
			}

		}

		if found == false {
			vulnerability.References = append(vulnerability.References, value);
		}

	}

}

func (vulnerability *Vulnerability) RemoveReference (value string) {

	var index int = -1;

	for r := 0; r < len(vulnerability.References); r++ {

		var other = vulnerability.References[r];

		if other == value {
			index = r;
			break;
		}

	}

	if index != -1 {
		vulnerability.References = append(vulnerability.References[:index], vulnerability.References[index + 1:]...);
	}

}

func (vulnerability *Vulnerability) SetReferences (values []string) {

	var filtered []string;

	for v := 0; v < len(values); v++ {

		var value = values[v];

		if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
			filtered = append(filtered, value);
		}

	}

	vulnerability.References = filtered;

}

func (vulnerability *Vulnerability) AddWeakness (value string) {

	if strings.HasPrefix(value, "CWE-") {

		var found bool = false;

		for w := 0; w < len(vulnerability.Weaknesses); w++ {

			var weakness = vulnerability.Weaknesses[w];

			if weakness == value {
				found = true;
				break;
			}

		}

		if found == false {
			vulnerability.Weaknesses = append(vulnerability.Weaknesses, value);
		}

	}

}

func (vulnerability *Vulnerability) RemoveWeakness (value string) {

	var index int = -1;

	for w := 0; w < len(vulnerability.Weaknesses); w++ {

		var other = vulnerability.Weaknesses[w];

		if other == value {
			index = w;
			break;
		}

	}

	if index != -1 {
		vulnerability.Weaknesses = append(vulnerability.Weaknesses[:index], vulnerability.Weaknesses[index + 1:]...);
	}

}

func (vulnerability *Vulnerability) SetWeaknesses (values []string) {

	var filtered []string;

	for v := 0; v < len(values); v++ {

		var value = values[v];

		if strings.HasPrefix(value, "CWE-") {
			filtered = append(filtered, value);
		}

	}

	vulnerability.Weaknesses = filtered;

}

